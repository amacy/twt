#!/usr/bin/env ruby
#  untitled
#
#  Created by Paolo Bosetti on 2009-12-03.
#  Copyright (c) 2009 University of Trento. All rights reserved.
#
require 'rubygems'
require "twitter"
require "optparse"
require "yaml"
require "pp"

VERSION = "0.1.4"
PROGRAM_NAME = "Twt"
DATA_DIR = "#{ENV['HOME']}/.twitter"
AUTH_FILE = "cfg.yaml"
DEFAULT_COUNT = 10
DEFAULT_WIDTH = 80
COMMANDS = %w|login logout post user friends mention reset|

class OptsError < Exception; end
class CredentialsError < Exception; end

class String
  COLORS = {
    :off     => 0 ,    # Turn off all attributes
    :bright  => 1 ,    # Set bright mode
    :underline => 4 ,    # Set underline mode
    :blink   => 5 ,    # Set blink mode
    :inverse => 7 ,    # Exchange foreground and background colors
    :hide    => 8 ,    # Hide text (foreground color would be the same as background)
    :black   => 30,    # Black text
    :red     => 31,    # Red text
    :green   => 32,    # Green text
    :yellow  => 33,    # Yellow text
    :blue    => 34,    # Blue text
    :magenta => 35,    # Magenta text
    :cyan    => 36,    # Cyan text
    :white   => 37,    # White text
    :default => 39,    # Default text color
  }
  
  def color(fg, bg=nil)
    raise ArgumentError, "Wrong text color #{fg}" unless COLORS[fg]
    raise ArgumentError, "Wrong background color #{bg}" if bg and not COLORS[bg]
    return self if fg == :off or fg == :default
    bg_col = "\e[#{COLORS[bg]}m" if bg
    "\e[#{COLORS[fg]}m#{bg_col}#{self}\e[0m"
  end
  
  def partition(w)
    if self.length <= w
      return [self]
    else
      return [self[0...w], self[w..-1].partition(w)]
    end
  end
  
  def partition_by_words(width, color=:green)
    words = self.split("\s")
    result = []
    buffer = []
    words.each do |w|
      if (buffer*" ").length + w.length < width then
        w = w.color(color) if w =~ /@.*/
        w = w.color(:underline) if w =~ /(http)(s*):\/\//
        buffer << w
      else
        result << buffer * " "
        buffer = []
      end
    end
    result << buffer * " "
    return result
  end
  
end

def warn(string)
  super(string.color(:red))
end

class Twt
  attr_accessor :raw
  def initialize
    Dir.mkdir(DATA_DIR) unless File.directory?(DATA_DIR)
    begin
      @cfg = File.open("#{DATA_DIR}/#{AUTH_FILE}") { |file| YAML.load(file) } || Hash.new
    rescue
      @cfg = Hash.new
    end
    
    @count  = (@cfg[:count] || 0)
    @latest = (@cfg[:latest] || {})
    @color  = (@cfg[:color] || :default).to_sym
    @raw = false
  end
  
  def connect
    httpauth = Twitter::HTTPAuth.new(@cfg[:user], @cfg[:pass])
    @client = Twitter::Base.new(httpauth)
  end
  
  def config=(h)
    @cfg.merge!(h)
    File.open("#{DATA_DIR}/#{AUTH_FILE}", "w") { |file| 
      YAML.dump(@cfg, file)
    }
  end
  
  def config
    @cfg
  end
  
  def reset
    if File.exist?("#{DATA_DIR}/#{AUTH_FILE}") then
      File.unlink("#{DATA_DIR}/#{AUTH_FILE}")
    else
      warn "Already reset"
    end
  end
  
  def login(credentials)
    credentials = credentials.split(":")
    begin
      raise CredentialsError unless credentials.size == 2
      self.config = {:user=>credentials[0],:pass=>credentials[1]}
      self.connect
      @client.user_timeline
      puts "Authorization succesfully completed."
    rescue Twitter::Unauthorized
      warn "Authorization error. Check User name and password."
    rescue CredentialsError
      warn "Login format error: Login with twt login USER:PASS"
    end
  end
  
  def logout
    self.config = {:user=>"",:pass=>""}
  end
  
  def query(kind, user=nil)
    self.connect
    puts "SHOWING LAST #{@count == 0 ? "UNREAD" : @count} #{kind.to_s.upcase} MESSAGES:"
    actual_timeline = @client.method(kind.to_sym)
    call_arg = Hash.new
    if @cfg[:count] and @cfg[:count] > 0 then
      call_arg = {:count=>@count}
    elsif @latest[kind]
      call_arg = {:since_id=>@latest[kind]}
    end
    if user then
      call_arg[:id] = user
    end
    tweets = actual_timeline.call(call_arg).reverse
    tweets.each {|tweet|
      if @raw then
        pp tweet
      else
        @latest[kind.to_sym] = tweet.id
        time = DateTime.parse(tweet.created_at)
        if @cfg[:compact] then
          timeshort = time.strftime("%m%d%H%M")
          head = "#{tweet.user.screen_name.color(@color)}/#{timeshort} "
          indent = (tweet.user.screen_name.length+timeshort.length+2)          
        else
          timeshort = time.strftime("%m/%d %H:%M")
          head = "[#{tweet.user.screen_name.color(@color)} #{timeshort}] "
          indent = (tweet.user.screen_name.length+timeshort.length+4)
        end
        text = tweet.text.partition_by_words((@cfg[:width] || DEFAULT_WIDTH)-indent, @color)
        text = text*("\n"+" "*indent)
        puts "#{head}#{text}"
        puts if @cfg[:space]
      end
    }
    self.config = {:latest => @latest}
  end
  
  def post(msg)
    self.connect
    if msg.length >= 140 then
      msg = msg[0...-3]+"..."
      warn "your message has been shortened to 140 chars."
    end
    begin
      @client.update(msg)
      puts "Succesfully posted \"#{msg}\""
    rescue
      warn "Error posting your message.\n Error was: #{$!}"
    end
  end
end

twt = Twt.new
opts = OptionParser.new
opts.banner = "Usage: twt [options] #{COMMANDS*'|'} [argument]\nArguments are:"

begin
  opts.on("-cCOUNT", "--count COUNT", "Messages to get (sticky)", Integer) {|v|
    twt.config = {:count => v}
  }
  opts.on("-wCOUNT", "--width COUNT", "Set message width (sticky)", Integer) {|v|
    twt.config = {:width => v}
  }
  opts.on("-r", "--raw", "Output raw data", TrueClass) {|v|
    twt.raw = v
  }
  opts.on("-s", "--space", "Toggle empty line between tweets (sticky)", TrueClass) {|v|
    twt.config = {:space => !twt.config[:space]}
  }
  opts.on("-p", "--compact", "Toggle compact heading (sticky)", TrueClass) {|v|
    twt.config = {:compact => !twt.config[:compact]}
  }
  opts.on("-kCOLOR", "--color COLOR", "Set color for user names (sticky)", String) {|v|
    twt.config = {:color => v}
  }
  opts.on("-v", "--version", "Print program version") {
    puts "twt version #{VERSION}"
    exit
  }
  
  rest = opts.parse ARGV
  CMD, ARG = rest
  raise OptsError unless COMMANDS.include?(CMD)
  
  if not File.exist?("#{DATA_DIR}/#{AUTH_FILE}") then
    puts "Welcome! you're using twt version #{VERSION}.\nPlease drop a tweet to @P4010 if you like it!"
  end

  case CMD
  when "login"
    twt.login(ARG)
  when "logout"
    twt.logout
  when "post"
    twt.post(ARG)
  when "user"
    twt.query(:user_timeline, ARG)
  when "friends"
    twt.query(:friends_timeline)
  when "mention"
    twt.query(:mentions)
  when "reset"
    twt.reset
  end
rescue OptsError
  warn "Must provide a command (either #{COMMANDS.inspect})"
  puts opts.to_s
  exit
rescue OptionParser::InvalidArgument
  warn "Invalid option argument"
  puts opts.to_s
  exit
rescue Twitter::Unauthorized
  warn "Invalid authentication. Login with twt login user:pass"
  exit
end
